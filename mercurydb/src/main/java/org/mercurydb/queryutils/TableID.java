package org.mercurydb.queryutils;

public class TableID<T> {
    /**
     * This value may wrap around, but we have built in machinery to prevent
     * this from becoming a problem. We allow the creation of Long.MAX_VALUE
     * names. We preserve all of the negative numbers for aliases so that the
     * usual machinery of creating aliases can proceed as usual even if all
     * of the names have been created.
     *
     * Note: This implies that the maximum number of classes which can be used
     * under MercuryDB is Long.MAX_VALUE classes. We believe this is an
     * acceptable limit as the amount of classes a Java program can have in
     * total is probably smaller than this number, based on expected
     * limitations of the compiler and physical memory of a modern machine
     * [CITATION NEEDED].
     */
    private static long counter = 0;

    /**
     * For efficiency reasons in accounting for unique TableIDs throughout a
     * client codebase, we have elected to have two regions for IDs (those
     * which are permanent [names], and those which are temporary [aliases]).
     * For this reason, names cannot be created after any aliases have been created.
     *
     * This distinction allows us to deal with wrap around of the alias IDs.
     * On wrap around, we will set the value back to firstAliasID.
     *
     * This flag will be used to prevent the creation of names after the first
     * alias has been created. When the first alias is created, set this to false,
     * and never allow any names to be created anymore (instead throw an exception).
     */
    private static boolean allowNames = true;

    /**
     * Initially 0, this value will be updated when the first alias is created
     * and never changed. Whenever the counter wraps around, it will be reset
     * to this value.
     */
    private static long firstAliasID = 0;

    /**
     * This is the ID value for this instance of a TableID. If this TableID is a
     * name, then it will be globally unique. If this TableID is an alias, it is
     * intended to be unique within an HgTuple. This assumption is safe at least
     * until you have Long.MAX_VALUE entries the HgTuple, and this assumes that
     * you have used all Long.MAX_VALUE names, so it may be even less restrictive.
     */
    private long id;

    /**
     * Create a new TableID with the current value of the static counter, and
     * increment the counter for the next instance.
     */
    private TableID() {
        id = counter++;
    }

    /**
     * Compare a this TableID with another generic TableID, determine whether they are
     * equal by trying to match their values.
     *
     * @param other A generic TableID against which to compare.
     * @return Whether the id values are equal.
     */
    public boolean equals(TableID other) {
        return this.id == other.id;
    }

    /**
     * Utility method to cast the objects retrieved from an HgTuple back to
     * the appropriate type which is captured by the generic type, T of this
     * instance of TableID.
     *
     * @param o The input object to be cast.
     * @return The object casted to its original type.
     */
    @SuppressWarnings("unchecked")
    public T castObject(Object o) {
        // TODO verify is this actually used (or verify it is not needed, and then remove it)
        return (T)o;
    }

    /**
     * Create a name.
     *
     * This is intended mainly for use by the Table classes generated by MercuryDB.
     * Users can create names as well, but only if they do so before creating any
     * aliases. If they violate this contract, this method will throw an
     * OutOfNamesException.
     *
     * Note: The fact that this throws an OutOfNamesException is a good thing because
     * it will cause users to think twice before using this method, since they will
     * have to account for the appropriate exception in their client code.
     *
     * @param <T> The type to represent.
     * @return a new TableID name representing the type T.
     * @throws OutOfNamesException in case all available name IDs have been used.
     */
    public static <T> TableID<T> createName() throws OutOfNamesException {
        // TODO call this from inside the Table* classes

        if (counter == Long.MIN_VALUE) {
            throw new OutOfNamesException();
        }

        // keep <T> for 1.6 compatibility
        return new TableID<T>();
    }

    /**
     * Create an alias.
     *
     * @param <T> The type to represent.
     * @return a new TableID alias representing the type T.
     */
    public static <T> TableID<T> createAlias() {
        // TODO call this from within a method "createAlias" of the Table* classes

        if (allowNames) {
            sealNames();
        }

        // when we wrap all the way back around to 0, we need to skip over the permanent names.
        if (counter == 0) {
            counter = firstAliasID;
        }

        // keep <T> for 1.6 compatibility
        return new TableID<T>();
    }

    public static class OutOfNamesException extends Exception {
        // TODO implement (is there anything to do here?)
    }

    /**
     * Tells us not to allow any more names to be created from this point forward.
     * Set the firstAliasID to the current value of counter, as this value
     * will be the value of the first alias, and is the smallest value
     * guaranteed to never be reserved by a permanent name.
     */
    private static void sealNames() {
        allowNames = false;
        firstAliasID = counter;
    }
}

// TODO remove the test code, below

class TableIdTestX {
}

class TableIdTestCase {
    void foo() {
        try {
            TableID<TableIdTestX> xName = TableID.<TableIdTestX>createName();
            TableIdTestX x = new TableIdTestX();
            Object o = x;
            TableIdTestX xx = xName.castObject(o); // castObject MIGHT not be necessary but lets keep it around just in case.
            TableIdTestX xx1 = (TableIdTestX)o;
        } catch (TableID.OutOfNamesException e) {
            e.printStackTrace();
        }
    }
}
