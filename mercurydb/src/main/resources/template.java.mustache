package {{packageName}};

import org.mercurydb.queryutils.*;
import java.util.*;

import com.google.common.collect.MapMaker;

import {{fullSourceClass}};

public class {{sourceClass}}{{tableSuffix}} {
    public static final int JOIN_ID = {{joinId}};

    public static final List<{{sourceClass}}> table = new ArrayList<>();

    public static final Class<{{sourceClass}}> containedClass = {{sourceClass}}.class;

    // Maps for indexed fields
    {{#fields}}
    {{#hasIndex}}
    private static Map<{{type}}, Set<{{sourceClass}}>> {{name}}Index = new HashMap<>();

    {{/hasIndex}}
    {{/fields}}
    public static void insert({{sourceClass}} val) {
        {{#fields}}
        {{#hasIndex}}
        // Populate {{name}} index
        Set<{{sourceClass}}> {{name}}Set = {{name}}Index.get(val.{{name}});
        if ({{name}}Set == null) {
            {{name}}Set = new HashSet<{{sourceClass}}>();//Collections.newSetFromMap(new WeakHashMap<{{sourceClass}}, Boolean>());
        }
        {{name}}Set.add(val);
        {{name}}Index.put(val.{{name}}, {{name}}Set);
        {{/hasIndex}}
        {{/fields}}
        // Populate standard table if T(val) == {{sourceClass}}
        if ({{sourceClass}}.class.equals(val.getClass()))
            table.add(val);
        {{#hasSuper}}
        // Populate super table indices
        {{cSuper}}{{tableSuffix}}.insert(val);
        {{/hasSuper}}
    }

    public static void remove({{sourceClass}} val) {
        // Remove from table
        if ({{sourceClass}}.class.equals(val.getClass()))
            table.remove(val);
        {{#fields}}
        {{#hasIndex}}
        // Remove from {{name}} index
        {{name}}Index.values().removeAll(Collections.singleton(val));
        {{/hasIndex}}
        {{/fields}}
        {{#hasSuper}}
        // Remove from {{cSuper}} indices (superclass)
        {{cSuper}}{{tableSuffix}}.remove(val);
        {{/hasSuper}}
        // Remove from subclass indices
        {{#subClasses}}
        if ({{toString}}{{tableSuffix}}.containedClass.isInstance(val)) {
            {{toString}}{{tableSuffix}}.remove({{toString}}{{tableSuffix}}.containedClass.cast(val));
            return;
        }
        {{/subClasses}}
    }

    // Set methods - make sure you use these on indexed fields for consistency!
    {{#fields}}
    {{^isFinal}}
    public static void set{{CCname}}({{sourceClass}} instance, {{_type}} val) {
        {{#hasIndex}}
        {{name}}Index.get(instance.{{name}}).remove(instance);
        instance.{{name}} = val;
        Set<{{sourceClass}}> {{name}}Set = {{name}}Index.get(instance.{{name}});
        if ({{name}}Set == null) {
            {{name}}Set = new HashSet<{{sourceClass}}>();//Collections.newSetFromMap(new WeakHashMap<{{sourceClass}}, Boolean>());;
            {{name}}Index.put(instance.{{name}}, {{name}}Set);
        }
        {{name}}Set.add(instance);
        {{/hasIndex}}
        {{^hasIndex}}
        instance.{{name}} = val;
        {{/hasIndex}}
    }

    {{/isFinal}}
    {{/fields}}

    // Get methods -- these are retrievals for attribute = value queries
    {{#fields}}
    public static HgStream<{{sourceClass}}> query{{CCname}}({{_type}} val) {
        {{#hasIndex}}
        Set<{{sourceClass}}> result = {{name}}Index.get(val);
        return result == null
                ? new Retrieval<{{sourceClass}}>(Collections.EMPTY_LIST, 0)
                : new Retrieval<{{sourceClass}}>(result, result.size());
        {{/hasIndex}}
        {{^hasIndex}}
        return stream().filter(field.{{name}},val);
        {{/hasIndex}}
    }

    {{/fields}}

    public static final class field {
        {{#fields}}
        public static final FieldExtractable<{{sourceClass}}, {{type}}> {{name}} = new FieldExtractable<{{sourceClass}}, {{type}}>() {
            @Override
            public {{type}} extractField({{sourceClass}} instance) {
                return (({{sourceClass}})instance).{{name}};
            }

            @Override
            public Class<{{sourceClass}}> getContainerClass() {
                return {{sourceClass}}.class;
            }

            @Override
            public boolean isIndexed() {
                {{#hasIndex}}
                return true;
                {{/hasIndex}}
                {{^hasIndex}}
                return false;
                {{/hasIndex}}
            }

            @Override
            public Map<{{type}}, Set<{{sourceClass}}>> getIndex() {
                {{#hasIndex}}
                return {{name}}Index;
                {{/hasIndex}}
                {{^hasIndex}}
                return null;
                {{/hasIndex}}
            }

            @Override
            public int getContainerId() {
                return JOIN_ID;
            }
        };

        {{/fields}}
    }

    public static class on {
        {{#fields}}
        public static final HgTupleStream {{name}} = stream().joinOn(field.{{name}});
        {{/fields}}
    }

    public static class eq {
        {{#fields}}
        public static FieldExtractableValue<{{sourceClass}}, {{type}}>
        {{name}}({{type}} val) {
            return new FieldExtractableValue<{{sourceClass}}, {{type}}>(field.{{name}}, val);
        }
        {{/fields}}
    }

    // alias equal = eq
    public static class equal extends eq {}


    // TODO ne/_neq_/notEqual, _lt_/lessThan, le/_leq_/lessThanOrEqual, _gt_/greaterThan, ge/_geq_/greaterThanOrEqual

    public static Retrieval<{{sourceClass}}> stream() {
        /*
         * Here we need to do a tree traversal such that
         * every possible subclass table is joined with
         * this classes table in the stream
         */

        Retrieval<{{sourceClass}}> result = new Retrieval<{{sourceClass}}>(table, table.size());
        {{#subClasses}}
        result = result.join({{toString}}{{tableSuffix}}.stream());
        {{/subClasses}}
        return result;
    }
}
