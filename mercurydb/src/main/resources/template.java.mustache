package {{packageName}};

import org.mercurydb.queryutils.*;
import java.util.*;

import com.google.common.collect.MapMaker;

import {{fullSourceClass}};

public class {{sourceClass}}{{tableSuffix}} {
    public static final TableID<{{sourceClass}}> ID = TableID.<{{sourceClass}}>createName();



    /**
     * Create a temporary alias for this table, for joins.
     */
    public static TableID<{{sourceClass}}> createAlias() {
        return TableID.<{{sourceClass}}>createAlias();
    }

    public static final List<{{sourceClass}}> table = new ArrayList<{{sourceClass}}>();

    public static final Class<{{sourceClass}}> containedClass = {{sourceClass}}.class;

    // Maps for indexed fields
    {{#fields}}
    {{#hasIndex}}
    private static Map<{{type}}, Set<{{sourceClass}}>> {{name}}Index = new HashMap<>();

    {{/hasIndex}}
    {{/fields}}
    public static void insert({{sourceClass}} val) {
        {{#fields}}
        {{#hasIndex}}
        // Populate {{name}} index
        Set<{{sourceClass}}> {{name}}Set = {{name}}Index.get(val.{{name}});
        if ({{name}}Set == null) {
            {{name}}Set = new HashSet<{{sourceClass}}>();//Collections.newSetFromMap(new WeakHashMap<{{sourceClass}}, Boolean>());
        }
        {{name}}Set.add(val);
        {{name}}Index.put(val.{{name}}, {{name}}Set);
        {{/hasIndex}}
        {{/fields}}
        // Populate standard table if T(val) == {{sourceClass}}
        if ({{sourceClass}}.class.equals(val.getClass()))
            table.add(val);
        {{#hasSuper}}
        // Populate super table indices
        {{cSuper}}{{tableSuffix}}.insert(val);
        {{/hasSuper}}
    }

    public static void remove({{sourceClass}} val) {
        // Remove from table
        if ({{sourceClass}}.class.equals(val.getClass()))
            table.remove(val);
        {{#fields}}
        {{#hasIndex}}
        // Remove from {{name}} index
        {{name}}Index.values().removeAll(Collections.singleton(val));
        {{/hasIndex}}
        {{/fields}}
        {{#hasSuper}}
        // Remove from {{cSuper}} indices (superclass)
        {{cSuper}}{{tableSuffix}}.remove(val);
        {{/hasSuper}}
        // Remove from subclass indices
        {{#subClasses}}
        if ({{toString}}{{tableSuffix}}.containedClass.isInstance(val)) {
            {{toString}}{{tableSuffix}}.remove({{toString}}{{tableSuffix}}.containedClass.cast(val));
            return;
        }
        {{/subClasses}}
    }

    // Set methods - make sure you use these on indexed fields for consistency!
    {{#fields}}
    {{^isFinal}}
    public static void set{{CCname}}({{sourceClass}} instance, {{_type}} val) {
        {{#hasIndex}}
        {{name}}Index.get(instance.{{name}}).remove(instance);
        instance.{{name}} = val;
        Set<{{sourceClass}}> {{name}}Set = {{name}}Index.get(instance.{{name}});
        if ({{name}}Set == null) {
            {{name}}Set = new HashSet<{{sourceClass}}>();//Collections.newSetFromMap(new WeakHashMap<{{sourceClass}}, Boolean>());;
            {{name}}Index.put(instance.{{name}}, {{name}}Set);
        }
        {{name}}Set.add(instance);
        {{/hasIndex}}
        {{^hasIndex}}
        instance.{{name}} = val;
        {{/hasIndex}}
    }

    {{/isFinal}}
    {{/fields}}

    public static final class field {
        {{#fields}}
        public static final FieldExtractableSeed<{{sourceClass}}> {{name}}(TableID<{{sourceClass}}> id) {
            return new FieldExtractableSeed<{{sourceClass}}>(id) {
                @Override
                public Object extractField(Object instance) {
                    return (({{sourceClass}})instance).{{name}};
                }

                @Override
                public Class<?> getContainerClass() {
                    return {{sourceClass}}.class;
                }

                @Override
                public boolean isIndexed() {
                    {{#hasIndex}}
                    return true;
                    {{/hasIndex}}
                    {{^hasIndex}}
                    return false;
                    {{/hasIndex}}
                }

                @Override
                public Map<Object, Set<Object>> getIndex() {
                    {{#hasIndex}}
                    return (Map) {{name}}Index;
                    {{/hasIndex}}
                    {{^hasIndex}}
                    return null;
                    {{/hasIndex}}
                }

                @Override
                public HgStream<{{sourceClass}}> getDefaultStream() {
                    return stream();
                }
            };
        }

        {{/fields}}
    }

    public static class on {
        {{#fields}}
        public static final HgTupleStream {{name}}() {
            return stream().joinOn(field.{{name}}(ID));
        }

        public static final HgTupleStream {{name}}(TableID<{{sourceClass}}> aliasId) {
            return stream().joinOn(field.{{name}}(aliasId));
        }
        {{/fields}}
    }

    public static class eq {
        {{#fields}}
        public static final FieldExtractableRelation<{{sourceClass}}>
        {{name}}({{type}} val) {
            return new FieldExtractableRelation<{{sourceClass}}>(field.{{name}}(ID), HgRelation.EQ, val);
        }
        {{/fields}}
    }

    // TODO neq, lt, leq, gt, geq

    public static Retrieval<{{sourceClass}}> stream() {
        /*
         * Here we need to do a tree traversal such that
         * every possible subclass table is joined with
         * this classes table in the stream
         */

        Retrieval<{{sourceClass}}> result = new Retrieval<{{sourceClass}}>(table, table.size());
        {{#subClasses}}
        result = result.join({{toString}}{{tableSuffix}}.stream());
        {{/subClasses}}
        return result;
    }
}
